<?php


/**
 * Implements hook_init().
 */
function cp_init() {
  module_load_include('routines.inc', 'cp', 'inc/cp');
}

/**
 * Implements hook_menu()
 */
function cp_menu() {
    $items = array();
    
    $items['parser'] = array(
        'access callback' => 'cp_user_access',
        'page callback' => 'cp_parser_page',
        'type' => MENU_CALLBACK,
        'file' => 'inc/cp.pages.inc'
    );
    
    $items['parser/%'] = array(
        'access callback' => 'cp_user_access',
        'page callback' => 'cp_parser_proccess_page',
        'page arguments' => array(1),
        'type' => MENU_CALLBACK,
        'file' => 'inc/cp.pages.inc'
    );
    
    $items['parser/visibility/%'] = array(
        'access callback' => 'cp_user_access',
        'page callback' => 'cp_parser_visibility_page',
        'page arguments' => array(2),
        'type' => MENU_CALLBACK,
        'file' => 'inc/cp.pages.inc'
    );

    $items['categories/%/save'] = array(
        'access callback' => 'cp_user_access',
        'page callback' => 'cp_category_save',
        'page arguments' => array(1),
        'type' => MENU_CALLBACK
    );

    $items['parser/step'] = array(
        'access callback' => TRUE,
        'page callback' => 'cp_parser_step',
        'type' => MENU_CALLBACK
    );

    $items['ozon/rebuild'] = array(
        'access callback' => TRUE,
        'page callback' => 'cp_ozon_rebuild',
        'type' => MENU_CALLBACK
    );

    $items['parser/list'] = array(
        'access callback' => TRUE,
        'page callback' => 'cp_admin_parser',
        'type' => MENU_CALLBACK
    );

    $items['parser/versions'] = array(
        'access callback' => TRUE,
        'page callback' => 'cp_admin_parser_versions',
        'type' => MENU_CALLBACK
    );

    $items['parser/versions/%/approve'] = array(
        'access callback' => TRUE,
        'page callback' => 'cp_admin_parser_version_approve',
        'page arguments' => array(2),
        'type' => MENU_CALLBACK
    );

    $items['parser/statuses'] = array(
        'access callback' => TRUE,
        'page callback' => 'cp_parser_statuses',
        'type' => MENU_CALLBACK
    );

    $items['parser/categories/update'] = array(
        'access callback' => TRUE,
        'page callback' => 'cp_parser_categories_update',
        'type' => MENU_CALLBACK
    );

    $items['parser/products/remove_old'] = array(
        'access callback' => TRUE,
        'page callback' => 'cp_parser_products_remove_old',
        'type' => MENU_CALLBACK
    );

    return $items;
}

function cp_parser_products_remove_old() {
    $filename = !empty($_GET['filename']) ? trim($_GET['filename']) : '';
    $provider = !empty($_GET['provider']) ? trim($_GET['provider']) : '';
    $updated = !empty($_GET['updated']) ? trim($_GET['updated']) : '';

    variable_set('test1', 'asasasa1');

    if ($filename && $provider && $updated) {
        _cp_delete_products($filename, $provider, $updated);
    }

    return;
}

function cp_parser_categories_update() {

    $filename = !empty($_GET['filename']) ? trim($_GET['filename']) : '';
    $provider = !empty($_GET['provider']) ? trim($_GET['provider']) : '';
    $prefix = !empty($_GET['prefix']) ? trim($_GET['prefix']) : '';

    if ($filename && $provider && $prefix) {
        _cp_update_categories($filename, $provider, $prefix);
    }
    print '121212';

    return;
}

function cp_admin_parser_version_approve($id) {
    $version = db_query('SELECT wpv.*, wpc.prefix, wpc.dir, wpc.param, wpc.provider
        FROM {wish2wish_parser_versions} wpv
        INNER JOIN {wish2wish_parser_categories} wpc ON wpc.id = wpv.parser_id
        WHERE wpv.id = :id', array(
        ':id' => $id
    ))->fetchObject();

    if ($version) {
        $filename = $_SERVER['DOCUMENT_ROOT'].'/data/'.$version->prefix.'/';

        if ($version->dir == 'ozon') {
            $filename .= 'div_';
        }

        if ($version->param) {
            $filename .= $version->param;
        } else {
            $filename .= $version->dir;
        }

        $filename .= '.xml';

        _cp_delete_products($filename, $version->provider);
        cp_move_products($version->version_id);
    }
    drupal_goto('/parser/versions');
}

function cp_move_products($code) {
    $start = microtime(true);
    _cp_move_items($code, 'wish2wish_products_temp', 'wish2wish_products');
    _cp_move_items($code, 'wish2wish_filter_values_temp', 'wish2wish_filter_values');

    $version = db_query("SELECT * FROM {wish2wish_parser_versions} WHERE version_id = :code", array(
        ':code' => $code
    ))->fetchObject();

    if ($version) {

        $versions = db_query("SELECT * FROM {wish2wish_parser_versions} WHERE parser_id = :id", array(
            ':id' => $version->parser_id
        ))->fetchAll();

        $codes = array();

        foreach ($versions as $v) {
            $codes[] = $v->version_id;
        }

        if(!empty($codes)) {

            db_delete('wish2wish_products_temp')
                ->condition('version_id', $codes, 'IN')
                ->execute();

            db_delete('wish2wish_filter_values_temp')
                ->condition('version_id', $codes, 'IN')
                ->execute();

            db_update('wish2wish_parser_versions')
                ->fields(array(
                    'removed' => 1
                ))
                ->condition('version_id', $codes, 'IN')
                ->execute();

        }

        db_query("UPDATE {wish2wish_parser_versions} SET approved = 1 WHERE version_id = :code", array(
            ':code' => $code
        ));

    }
    print microtime(true) - $start;
}

function _cp_move_items($code, $fromTable, $toTable, $limit = 10000) {

    $count  = db_query("SELECT COUNT(*) FROM {$fromTable} WHERE version_id = :vid", array(
        ':vid' => $code
    ))->fetchField();

    $start = 0;
    $_count = 0;

    while ($start < $count) {
        $records = db_query("SELECT * FROM {$fromTable} LIMIT $start, $limit");

        foreach ($records as $record) {
            $vars = get_object_vars($record);
            $insertsVars = array();
            $insertsValues = array();
            $placeholders = array();
            foreach ($vars as $var => $value) {
                if (!in_array($var, array('id', 'version_id'))) {
                    $insertsVars[] = $var;
                    $insertsValues[] = $value;
                    $placeholders[':'.$var] = $value;
                }
            }
            if (!empty($insertsVars)) {
                db_query("INSERT INTO {$toTable} (".implode(', ', $insertsVars).") VALUES (".implode(", ", array_keys($placeholders)).")", $placeholders);
            }
            $_count++;
        }
        $start += $limit;
    }
}


function cp_admin_parser_versions() {
    $pid = (int)arg(2);
    $query = db_select('wish2wish_parser_versions', 'wpv');
    $query->innerJoin('wish2wish_parser_categories', 'wpc', 'wpc.id = wpv.parser_id');
    $query->fields('wpc');
    $query->fields('wpv', array('created', 'data', 'approved', 'removed'));
    $query->addExpression('wpv.id', 'versionId');
    $query->orderBy('wpv.created', 'DESC');
    if ($pid) {
        $query->condition('wpv.parser_id', $pid);
    }
    $versions = $query->execute();
    ob_start();
    include 'tpl/cp.admin.parsers.versions.tpl.php';
    return ob_get_clean();
}

function cp_admin_parser() {
    global $user;

    ob_start();
    include 'tpl/cp.admin.parsers.tpl.php';
    return ob_get_clean();
}

function cp_ozon_rebuild() {
    ini_set('display_errors', 1);
    error_reporting(E_ALL);

}

function cp_parser_statuses() {
    $parsers = db_select('wish2wish_parser_categories', 'wpc')
        ->fields('wpc')
        ->execute();
    $statuses = array();
    if ($parsers) {
        foreach ($parsers as $status) {
            $statusText = "Ошибка";
            switch ($status->current_status) {
                case 0:
                    $statusText = "Завершен";
                    break;
                case 1:
                    $statusText = "Загружается каталог";
                    break;
                case 2:
                    $statusText = "Каталог загружен. Ожидание.";
                    break;
                case 3:
                    $statusText = "Парсинг";
                    break;
                case 4:
                    $statusText = "Парсинг";
                    break;
            }
            $statuses[] = array(
                'id' => $status->id,
                'status' => $status->current_status,
                'linkText' => $status->current_status > 0 ? 'Ожидание' : 'Запустить',
                'statusText' => $statusText,
                'lastAction' => date('d.m.Y H:i', $status->last_action)
            );
        }
    }
    $result = array(
        'parsers' => $statuses
    );
    print drupal_json_encode($result);
    die();
}

function cp_parser_log_write($message) {
    $time = time();

    db_query("INSERT INTO {wish2wish_parser_log} VALUES (NULL, :t, :m)", array(
        ':t' => $time,
        ':m' => $message
    ));
}


function cp_parser_step() {
    global $user;

    if ((!isset($_GET['username']) || $_GET['username'] != 'admin' || !user_authenticate($_GET['username'], $_GET['password'])) && $user->uid != 5) {
        cp_parser_log_write('Попытка доступа без пароля.');
        print 'Access denied';
        return;
    }
    ini_set('display_errors', 1);
    error_reporting(E_ALL);
    $time = time();
    $manual = !empty($_REQUEST['manual']) ? $_REQUEST['manual'] : 0;
    $working = db_query("SELECT * FROM {wish2wish_parser_categories} WHERE current_status > 0")->fetchObject();

    $p_c = variable_get('parser_continue', null);
    if ($p_c) {
        $function = "_cp_".$p_c['prefix']."_items_parser";
        cp_parser_log_write('Продолжение парсинга предыдущего файла');
        cp_set_parser_status($working->id, 3);
        $output = $function($p_c['prefix'], $p_c['provider'], $p_c['step_param']);
        print $output;
        if ($output == 'noenoughtime') {
            cp_parser_log_write('Парсинг файла не завершен. Парсинг будет продолжен при следующем запуске.');
            return;
        }
        cp_parser_log_write('Парсинг завершен.');
        cp_parser_finish($working->id);
        $delta = db_query("SELECT MAX(delta) FROM {wish2wish_parser_categories}")->fetchField();
        db_query("UPDATE {wish2wish_parser_categories} SET current_status = 0, last_action = :last_action, delta = :delta WHERE id = :id", array(
            ':last_action' => $time,
            ':delta' => $delta+1,
            ':id' => $working->id
        ));
        return;
    }

    if ($working && $time - $working->last_action < 601 && in_array($working->current_status, array(1, 3, 4))) {
        print 'Working<br />';
        return;
    } elseif($working) {
        print 'Repeat/Continue task.<br />';
        $current_step = $working;
    } else {
        print 'New task<br />';
        $current_step = db_query("SELECT * FROM {wish2wish_parser_categories}" . ($manual ? " WHERE id = $manual" : '') . " ORDER BY delta ASC, id ASC")->fetchObject();
    }

    if (!$current_step) {
        return;
    }

    if ($current_step->current_status == 0 && $current_step->last_action + 86400 > $time && !$manual) {
        return;
    }

    if (in_array($current_step->current_status, array(0, 1))) { //Качаем каталог
        print 'Downloading files<br />';
        cp_parser_log_write('Начало загрузки файла '.$current_step->host.$current_step->filename);
        cp_set_parser_status($current_step->id, 1);
        $loaded = _cp_load_data($current_step->prefix, $current_step->host, $current_step->filename, $current_step->param ? $current_step-> param : null);
        if ($loaded) {
            cp_parser_log_write('Файл '.$current_step->host.$current_step->filename.' успешно загружен.');
            cp_set_parser_status($current_step->id, 2);
        } else {
            cp_parser_log_write('Ошибка при загрузке Файла '.$current_step->host.$current_step->filename);
            cp_set_parser_status($current_step->id, 0);
            db_query("UPDATE {wish2wish_parser_categories} SET last_action = :last_action, errors = :errors WHERE id = :id", array(
                ':last_action' => $time,
                ':errors' => $current_step->errors+1,
                ':id' => $current_step->id
            ));
        }
    } elseif($current_step->current_status == 2) {//Парсим данные
        print 'Parsing items<br />';
        $function = "_cp_".$current_step->prefix."_items_parser";
        cp_parser_log_write('Начало парсинга файла '.$current_step->host.$current_step->filename);
        cp_set_parser_status($current_step->id, 3);
        $stats = array(
            'noImg' => 0,
            'moreThan1img' => 0,
            'totalCount' => 0,
            'withParams' => 0
        );
        variable_set('stats', $stats);
        $output = $function($current_step->prefix, $current_step->provider, $current_step->param);
        print $output;
        if ($output == 'noenoughtime') {
            cp_set_parser_status($current_step->id, 4);
            cp_parser_log_write('Парсинг файла '.$current_step->host.$current_step->filename.' не завершен. Парсинг будет продолжен при следующем запуске.');
            return;
        }
        cp_parser_log_write('Парсинг файла '.$current_step->host.$current_step->filename.' завершен.<br />'.$output);
        cp_parser_finish($current_step->id);
        $delta = db_query("SELECT MAX(delta) FROM {wish2wish_parser_categories}")->fetchField();
        db_query("UPDATE {wish2wish_parser_categories} SET current_status = 0, last_action = :last_action, delta = :delta WHERE id = :id", array(
            ':last_action' => $time,
            ':delta' => $delta+1,
            ':id' => $current_step->id
        ));
    }

}

function cp_parser_finish($parserId) {
    $uniqId = uniqid();
//    db_query("UPDATE {wish2wish_products_temp} SET version_id = :versionId WHERE version_id = '0'", array(
//        ':versionId' => $uniqId
//    ));
//    db_query("UPDATE {wish2wish_filter_values_temp} SET version_id = :versionId WHERE version_id = '0'", array(
//        ':versionId' => $uniqId
//    ));
    db_insert('wish2wish_parser_versions')
        ->fields(array(
            'parser_id' => $parserId,
            'version_id' => $uniqId,
            'created' => time(),
            'data' => serialize(variable_get('stats'))
        ))->execute();
    variable_set('stats', array(
        'noImg' => 0,
        'moreThan1img' => 0,
        'totalCount' => 0,
        'withParams' => 0
    ));
}

function cp_set_parser_status($id, $status) {
    db_query("UPDATE {wish2wish_parser_categories} SET last_action = :last_action, current_status = :status WHERE id = :id", array(
        ':last_action' => time(),
        ':status' => $status,
        ':id' => $id
    ));
}

//
//function cp_parser_step() {
//    if (!isset($_GET['username']) || $_GET['username'] != 'admin' || !user_authenticate($_GET['username'], $_GET['password'])) {
//        cp_parser_log_write('Попытка доступа без пароля.');
//        print 'Access denied';
//        return;
//    }
//    ini_set('display_errors', 1);
//    error_reporting(E_ALL);
//    $time = time();
//    $working = db_query("SELECT * FROM {wish2wish_parser_categories} WHERE current_status > 0")->fetchObject();
//
//    $p_c = variable_get('parser_continue', null);
//    if ($p_c) {
////        print '<pre>'.print_r($_SESSION['parser_continue'], 1).'</pre>';
//        $function = "_cp_".$p_c['prefix']."_items_parser";
//        cp_parser_log_write('Продолжение парсинга предыдущего файла');
//        $output = $function($p_c['prefix'], $p_c['provider'], $p_c['step_param']);
//        print $output;
//        if ($output == 'noenoughtime') {
//            cp_parser_log_write('Парсинг файла не завершен. Парсинг будет продолжен при следующем запуске.');
//            return;
//        }
//        cp_parser_log_write('Парсинг завершен.');
//        $delta = db_query("SELECT MAX(delta) FROM {wish2wish_parser_categories}")->fetchField();
//        db_query("UPDATE {wish2wish_parser_categories} SET current_status = 0, last_action = :last_action, delta = :delta WHERE id = :id", array(
//            ':last_action' => $time,
//            ':delta' => $delta+1,
//            ':id' => $working->id
//        ));
//        return;
//    }
//
//    if ($working && $time - $working->last_action < 601) {
//        print 'Working<br />';
//        return;
//    } elseif($working) {
//        print 'Working error. Repeat task.<br />';
//        $current_step = $working;
//    } else {
//        print 'New task<br />';
//        $current_step = db_query("SELECT * FROM {wish2wish_parser_categories} ORDER BY delta ASC, id ASC")->fetchObject();
//    }
//
//    if ($current_step->current_status == 0 && $current_step->last_action + 86400 > $time) {
//        return;
//    }
//
//    if (!$current_step) {
//        return;
//    }
//
//    if ($current_step->current_status == 0) { //Качаем каталог
//        print 'Downloading files<br />';
//        cp_parser_log_write('Начало загрузки файла '.$current_step->host.$current_step->filename);
//        $loaded = _cp_load_data($current_step->prefix, $current_step->host, $current_step->filename, $current_step->param ? $current_step-> param : null);
//        if ($loaded) {
//            cp_parser_log_write('Файл '.$current_step->host.$current_step->filename.' успешно загружен.');
//            db_query("UPDATE {wish2wish_parser_categories} SET current_status = 1, last_action = :last_action WHERE id = :id", array(
//                ':last_action' => $time,
//                ':id' => $current_step->id
//            ));
//        } else {
//            cp_parser_log_write('Ошибка при загрузке Файла '.$current_step->host.$current_step->filename);
//            db_query("UPDATE {wish2wish_parser_categories} SET last_action = :last_action, errors = :errors WHERE id = :id", array(
//                ':last_action' => $time,
//                ':errors' => $current_step->errors+1,
//                ':id' => $current_step->id
//            ));
//        }
//    } elseif($current_step->current_status == 1) {//Парсим данные
//        print 'Parsing items<br />';
//        $function = "_cp_".$current_step->prefix."_items_parser";
//        cp_parser_log_write('Начало парсинга файла '.$current_step->host.$current_step->filename);
//        $output = $function($current_step->prefix, $current_step->provider, $current_step->param);
//        print $output;
//        if ($output == 'noenoughtime') {
//            cp_parser_log_write('Парсинг файла '.$current_step->host.$current_step->filename.' не завершен. Парсинг будет продолжен при следующем запуске.');
//            return;
//        }
//        cp_parser_log_write('Парсинг файла '.$current_step->host.$current_step->filename.' завершен.<br />'.$output);
//        $delta = db_query("SELECT MAX(delta) FROM {wish2wish_parser_categories}")->fetchField();
//        db_query("UPDATE {wish2wish_parser_categories} SET current_status = 0, last_action = :last_action, delta = :delta WHERE id = :id", array(
//            ':last_action' => $time,
//            ':delta' => $delta+1,
//            ':id' => $current_step->id
//        ));
//    }
//
//}

function cp_user_access() {
    global $user;
    
    return $user->uid == 1;
}